package django_session

import (
	"encoding/json"
	"strings"
	"testing"
	"time"
)

func TestB62Decode(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected int64
		wantErr  bool
	}{
		{"zero", "0", 0, false},
		{"simple", "1", 1, false},
		{"larger", "Z", 35, false},
		{"timestamp-like", "1vhS27", 1768739851, false},
		{"negative", "-5", -5, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := b62Decode(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("b62Decode() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if result != tt.expected {
				t.Errorf("b62Decode() = %v, want %v", result, tt.expected)
			}
		})
	}
}

func TestB64Decode(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
		wantErr  bool
	}{
		{
			name:     "no padding needed",
			input:    "eyJmb28iOiJiYXIifQ",
			expected: `{"foo":"bar"}`,
			wantErr:  false,
		},
		{
			name:     "padding needed",
			input:    "SGVsbG8",
			expected: "Hello",
			wantErr:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := b64Decode(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("b64Decode() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if string(result) != tt.expected {
				t.Errorf("b64Decode() = %v, want %v", string(result), tt.expected)
			}
		})
	}
}

func TestDjangoSignerSignature(t *testing.T) {
	signer := NewDjangoSigner("your-secret-key-here-change-in-production")

	// Test that signature is consistent
	value := "test-value"
	sig1 := signer.signature(value)
	sig2 := signer.signature(value)

	if sig1 != sig2 {
		t.Errorf("signature() not consistent: %v != %v", sig1, sig2)
	}

	// Test that different values produce different signatures
	value2 := "different-value"
	sig3 := signer.signature(value2)

	if sig1 == sig3 {
		t.Errorf("signature() same for different values")
	}
}

func TestConstantTimeCompare(t *testing.T) {
	tests := []struct {
		name     string
		a        string
		b        string
		expected bool
	}{
		{"equal strings", "hello", "hello", true},
		{"different strings", "hello", "world", false},
		{"different lengths", "hello", "hello!", false},
		{"empty strings", "", "", true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := constantTimeCompare(tt.a, tt.b)
			if result != tt.expected {
				t.Errorf("constantTimeCompare() = %v, want %v", result, tt.expected)
			}
		})
	}
}

func TestDjangoSignerUnsign(t *testing.T) {
	signer := NewDjangoSigner("test-secret-key")

	tests := []struct {
		name      string
		value     string
		wantErr   bool
		setupSign bool
	}{
		{
			name:      "valid signature",
			value:     "test-value",
			wantErr:   false,
			setupSign: true,
		},
		{
			name:      "no separator",
			value:     "no-separator-here",
			wantErr:   true,
			setupSign: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var signedValue string
			if tt.setupSign {
				sig := signer.signature(tt.value)
				signedValue = tt.value + ":" + sig
			} else {
				signedValue = tt.value
			}

			result, err := signer.Unsign(signedValue)
			if (err != nil) != tt.wantErr {
				t.Errorf("Unsign() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && result != tt.value {
				t.Errorf("Unsign() = %v, want %v", result, tt.value)
			}
		})
	}
}

func TestDjangoSignerUnsignTimestamp(t *testing.T) {
	signer := NewDjangoSigner("test-secret-key")

	// Create a properly signed timestamped value
	timestamp := time.Now().Unix()
	timestampB62 := b62Encode(timestamp)
	value := "test-value:" + timestampB62
	sig := signer.signature(value)
	signedValue := value + ":" + sig

	// Test unsigning
	result, err := signer.UnsignTimestamp(signedValue, nil)
	if err != nil {
		t.Errorf("UnsignTimestamp() error = %v", err)
		return
	}
	if result != "test-value" {
		t.Errorf("UnsignTimestamp() = %v, want %v", result, "test-value")
	}

	// Test with maxAge
	maxAge := 10 * time.Second
	result, err = signer.UnsignTimestamp(signedValue, &maxAge)
	if err != nil {
		t.Errorf("UnsignTimestamp() with maxAge error = %v", err)
	}
}

func TestDecodeSessionData_RealData(t *testing.T) {
	secretKey := "your-secret-key-here-change-in-production"

	// Session data generated by Django's SessionStore (with django.contrib.sessions.SessionStore salt)
	sessionData := ".eJyrVopPLC3JiC8tTi2Kz0xRslIyNDJW0kEWTUpMzk7NA0mlZCXmpefrJefnlRRlJumBlOhBZYv1fPNTUnOcoGprAWNEH5I:1vhTod:qb-B8ugO7TAqM_-uzlkfY2nOY_qVJDf_ebrKhZx9vrw"
	expectedID := "123"

	// Test decoding
	userID, err := DecodeSessionData(sessionData, secretKey)
	if err != nil {
		t.Errorf("DecodeSessionData() error = %v", err)
		return
	}

	if userID != expectedID {
		t.Errorf("DecodeSessionData() = %v, want %v", userID, expectedID)
	}

	t.Logf("Successfully decoded user ID: %s", userID)
}

func TestUnsignObject_Compressed(t *testing.T) {
	secretKey := "your-secret-key-here-change-in-production"
	// Use the Django sessions salt
	signer := &DjangoSigner{
		SecretKey: secretKey,
		Salt:      "django.contrib.sessions.SessionStore",
		Sep:       ":",
		Algorithm: "sha256",
	}

	// Fresh compressed session data generated by Django SessionStore
	sessionData := ".eJyrVopPLC3JiC8tTi2Kz0xRslIyNDJW0kEWTUpMzk7NA0mlZCXmpefrJefnlRRlJumBlOhBZYv1fPNTUnOcoGprAWNEH5I:1vhTod:qb-B8ugO7TAqM_-uzlkfY2nOY_qVJDf_ebrKhZx9vrw"

	// Test decoding
	result, err := signer.UnsignObject(sessionData, nil)
	if err != nil {
		t.Errorf("UnsignObject() error = %v", err)
		return
	}

	// Check that we got the expected fields
	if result == nil {
		t.Error("UnsignObject() returned nil")
		return
	}

	// Print the decoded session for debugging
	t.Logf("Decoded session data: %+v", result)

	// Check for _auth_user_id
	if _, ok := result["_auth_user_id"]; !ok {
		t.Error("_auth_user_id not found in decoded session")
	}

	// Verify the user ID value
	if userID, ok := result["_auth_user_id"].(string); ok {
		if userID != "123" {
			t.Errorf("Expected user ID '123', got '%s'", userID)
		}
	} else {
		t.Error("_auth_user_id is not a string")
	}
}

func TestDecodeSessionData_InvalidData(t *testing.T) {
	secretKey := "your-secret-key-here-change-in-production"

	tests := []struct {
		name        string
		sessionData string
		wantErr     bool
	}{
		{
			name:        "empty string",
			sessionData: "",
			wantErr:     true,
		},
		{
			name:        "invalid base64",
			sessionData: "not-valid-base64!!!",
			wantErr:     true,
		},
		{
			name:        "valid base64 but invalid signature",
			sessionData: "eyJmb28iOiJiYXIifQ:1vhS27:InvalidSignature",
			wantErr:     true,
		},
		{
			name:        "tampered data",
			sessionData: ".eJxVjDsOwjAQRO_iGlnBf1PS5wzWenfBAWRLcVIh7k4ipYBuNO_NvEWCdSlp7TynicRFnMXpt8uAT657oAfUe5PY6jJPWe6KPGiXYyN-XQ_376BAL9vaMWj21rDTcDNGhxijQ28iKUCbVR7cwAHZoqbIQNYDKpudCrwlncXnC-ksOHE:1vhS27:TAMPERED",
			wantErr:     true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := DecodeSessionData(tt.sessionData, secretKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DecodeSessionData() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestDecodeSessionData_DifferentSecretKey(t *testing.T) {
	sessionData := ".eJxVjDsOwjAQRO_iGlnBf1PS5wzWenfBAWRLcVIh7k4ipYBuNO_NvEWCdSlp7TynicRFnMXpt8uAT657oAfUe5PY6jJPWe6KPGiXYyN-XQ_376BAL9vaMWj21rDTcDNGhxijQ28iKUCbVR7cwAHZoqbIQNYDKpudCrwlncXnC-ksOHE:1vhS27:Ec6bvwN-OfuTDCWwRrivygOsusutHIHclVE2Zl8ikrM"
	wrongSecretKey := "wrong-secret-key"

	// Should fail with wrong secret key
	_, err := DecodeSessionData(sessionData, wrongSecretKey)
	if err == nil {
		t.Error("DecodeSessionData() should fail with wrong secret key")
	}
}

func TestB64EncodeDecode(t *testing.T) {
	tests := []struct {
		name  string
		input string
	}{
		{"simple", "hello world"},
		{"json", `{"foo":"bar"}`},
		{"special chars", "test@#$%^&*()"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			encoded := b64Encode([]byte(tt.input))
			decoded, err := b64Decode(encoded)
			if err != nil {
				t.Errorf("b64Decode() error = %v", err)
				return
			}
			if string(decoded) != tt.input {
				t.Errorf("roundtrip failed: got %v, want %v", string(decoded), tt.input)
			}
		})
	}
}

func TestDecodeSessionDataWithMaxAge(t *testing.T) {
	secretKey := "your-secret-key-here-change-in-production"

	// Create a fresh session dynamically (instead of using hardcoded old data)
	signer := &DjangoSigner{
		SecretKey: secretKey,
		Salt:      "django.contrib.sessions.SessionStore",
		Sep:       ":",
		Algorithm: "sha256",
	}
	freshTimestamp := time.Now().Unix()
	freshTimestampB62 := b62Encode(freshTimestamp)

	freshTestData := map[string]interface{}{"_auth_user_id": "123"}
	freshData, _ := json.Marshal(freshTestData)
	freshBase64Data := b64Encode(freshData)
	freshValue := freshBase64Data + ":" + freshTimestampB62
	freshSig := signer.signature(freshValue)
	sessionData := freshValue + ":" + freshSig

	// Test with reasonable max age (should pass since session is fresh)
	userID, err := DecodeSessionDataWithMaxAge(sessionData, secretKey, 3600) // 1 hour
	if err != nil {
		t.Errorf("DecodeSessionDataWithMaxAge() with reasonable max age error = %v", err)
		return
	}
	if userID != "123" {
		t.Errorf("Expected user ID '123', got '%s'", userID)
	}

	// Create an old session for expiry testing
	oldTimestamp := time.Now().Unix() - 7200 // 2 hours ago
	oldTimestampB62 := b62Encode(oldTimestamp)

	oldTestData := map[string]interface{}{"_auth_user_id": "456"}
	oldData, _ := json.Marshal(oldTestData)
	oldBase64Data := b64Encode(oldData)
	oldValue := oldBase64Data + ":" + oldTimestampB62
	oldSig := signer.signature(oldValue)
	oldSession := oldValue + ":" + oldSig

	// Test with short max age (should fail)
	_, err = DecodeSessionDataWithMaxAge(oldSession, secretKey, 3600) // 1 hour max age
	if err == nil {
		t.Error("DecodeSessionDataWithMaxAge() should fail for old session with short max age")
	}

	// Test with long max age (should pass)
	userID, err = DecodeSessionDataWithMaxAge(oldSession, secretKey, 10800) // 3 hours max age
	if err != nil {
		t.Errorf("DecodeSessionDataWithMaxAge() with long max age error = %v", err)
		return
	}
	if userID != "456" {
		t.Errorf("Expected user ID '456', got '%s'", userID)
	}
}

func TestUnsignTimestampExpiry(t *testing.T) {
	signer := NewDjangoSigner("test-secret-key")

	// Create an old session (2 hours ago)
	oldTimestamp := time.Now().Unix() - 7200
	timestampB62 := b62Encode(oldTimestamp)
	value := "test-value:" + timestampB62
	sig := signer.signature(value)
	signedValue := value + ":" + sig

	// Test without max age (should pass)
	result, err := signer.UnsignTimestamp(signedValue, nil)
	if err != nil {
		t.Errorf("UnsignTimestamp() without max age error = %v", err)
	}
	if result != "test-value" {
		t.Errorf("UnsignTimestamp() = %v, want %v", result, "test-value")
	}

	// Test with short max age (should fail)
	maxAge := 1 * time.Hour
	_, err = signer.UnsignTimestamp(signedValue, &maxAge)
	if err == nil {
		t.Error("UnsignTimestamp() should fail for old timestamp with short max age")
	}

	// Test with long max age (should pass)
	maxAge = 3 * time.Hour
	result, err = signer.UnsignTimestamp(signedValue, &maxAge)
	if err != nil {
		t.Errorf("UnsignTimestamp() with long max age error = %v", err)
	}
	if result != "test-value" {
		t.Errorf("UnsignTimestamp() = %v, want %v", result, "test-value")
	}
}

func TestSignObject(t *testing.T) {
	secretKey := "your-secret-key-here-change-in-production"
	signer := &DjangoSigner{
		SecretKey: secretKey,
		Salt:      "django.contrib.sessions.SessionStore",
		Sep:       ":",
		Algorithm: "sha256",
	}

	tests := []struct {
		name     string
		data     map[string]interface{}
		compress bool
	}{
		{
			name: "simple uncompressed",
			data: map[string]interface{}{
				"_auth_user_id": "123",
				"username":      "testuser",
			},
			compress: false,
		},
		{
			name: "simple compressed",
			data: map[string]interface{}{
				"_auth_user_id": "456",
				"username":      "anotheruser",
			},
			compress: true,
		},
		{
			name: "complex data",
			data: map[string]interface{}{
				"_auth_user_id": "789",
				"username":      "complexuser",
				"permissions":   []string{"read", "write", "admin"},
				"metadata": map[string]interface{}{
					"last_login": "2026-01-18",
					"ip_address": "127.0.0.1",
				},
			},
			compress: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Sign the object
			signed, err := signer.SignObject(tt.data, tt.compress)
			if err != nil {
				t.Errorf("SignObject() error = %v", err)
				return
			}

			// Verify we got a signed string
			if signed == "" {
				t.Error("SignObject() returned empty string")
				return
			}

			// Verify it has the expected format (value:timestamp:signature)
			parts := strings.Split(signed, ":")
			if len(parts) != 3 {
				t.Errorf("SignObject() result has %d parts, want 3", len(parts))
				return
			}

			// Verify we can unsign it
			decoded, err := signer.UnsignObject(signed, nil)
			if err != nil {
				t.Errorf("UnsignObject() error = %v", err)
				return
			}

			// Verify the data matches
			if decoded["_auth_user_id"] != tt.data["_auth_user_id"] {
				t.Errorf("_auth_user_id mismatch: got %v, want %v",
					decoded["_auth_user_id"], tt.data["_auth_user_id"])
			}

			t.Logf("Successfully signed and verified: %s", tt.name)
		})
	}
}

func TestEncodeSessionData(t *testing.T) {
	secretKey := "your-secret-key-here-change-in-production"

	tests := []struct {
		name           string
		userID         string
		additionalData map[string]interface{}
	}{
		{
			name:           "user only",
			userID:         "100",
			additionalData: nil,
		},
		{
			name:   "user with username",
			userID: "200",
			additionalData: map[string]interface{}{
				"username": "johndoe",
			},
		},
		{
			name:   "user with multiple fields",
			userID: "300",
			additionalData: map[string]interface{}{
				"username":   "janedoe",
				"email":      "jane@example.com",
				"last_login": "2026-01-18T10:00:00Z",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Encode session
			encoded, err := EncodeSessionData(tt.userID, secretKey, tt.additionalData)
			if err != nil {
				t.Errorf("EncodeSessionData() error = %v", err)
				return
			}

			// Verify we got a non-empty string
			if encoded == "" {
				t.Error("EncodeSessionData() returned empty string")
				return
			}

			// Decode it back and verify
			decodedUserID, err := DecodeSessionData(encoded, secretKey)
			if err != nil {
				t.Errorf("DecodeSessionData() error = %v", err)
				return
			}

			if decodedUserID != tt.userID {
				t.Errorf("User ID mismatch: got %v, want %v", decodedUserID, tt.userID)
			}

			t.Logf("Successfully encoded and decoded session for user %s", tt.userID)
		})
	}
}

func TestUpdateSessionData(t *testing.T) {
	secretKey := "your-secret-key-here-change-in-production"

	// Create initial session
	initialData := map[string]interface{}{
		"username": "originaluser",
		"email":    "original@example.com",
	}

	sessionData, err := EncodeSessionData("999", secretKey, initialData)
	if err != nil {
		t.Fatalf("Failed to create initial session: %v", err)
	}

	tests := []struct {
		name    string
		updates map[string]interface{}
		verify  func(t *testing.T, decoded map[string]interface{})
	}{
		{
			name: "update username",
			updates: map[string]interface{}{
				"username": "updateduser",
			},
			verify: func(t *testing.T, decoded map[string]interface{}) {
				if decoded["username"] != "updateduser" {
					t.Errorf("username not updated: got %v", decoded["username"])
				}
				if decoded["_auth_user_id"] != "999" {
					t.Errorf("user_id changed unexpectedly: got %v", decoded["_auth_user_id"])
				}
			},
		},
		{
			name: "add new field",
			updates: map[string]interface{}{
				"new_field": "new_value",
			},
			verify: func(t *testing.T, decoded map[string]interface{}) {
				if decoded["new_field"] != "new_value" {
					t.Errorf("new_field not added: got %v", decoded["new_field"])
				}
			},
		},
		{
			name: "delete field",
			updates: map[string]interface{}{
				"email": nil,
			},
			verify: func(t *testing.T, decoded map[string]interface{}) {
				if _, exists := decoded["email"]; exists {
					t.Errorf("email not deleted: got %v", decoded["email"])
				}
			},
		},
		{
			name: "multiple updates",
			updates: map[string]interface{}{
				"username": "multiupdate",
				"email":    "newemail@example.com",
				"role":     "admin",
			},
			verify: func(t *testing.T, decoded map[string]interface{}) {
				if decoded["username"] != "multiupdate" {
					t.Errorf("username not updated: got %v", decoded["username"])
				}
				if decoded["email"] != "newemail@example.com" {
					t.Errorf("email not updated: got %v", decoded["email"])
				}
				if decoded["role"] != "admin" {
					t.Errorf("role not added: got %v", decoded["role"])
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Update session
			updated, err := UpdateSessionData(sessionData, secretKey, tt.updates)
			if err != nil {
				t.Errorf("UpdateSessionData() error = %v", err)
				return
			}

			// Decode and verify
			signer := &DjangoSigner{
				SecretKey: secretKey,
				Salt:      "django.contrib.sessions.SessionStore",
				Sep:       ":",
				Algorithm: "sha256",
			}

			decoded, err := signer.UnsignObject(updated, nil)
			if err != nil {
				t.Errorf("UnsignObject() error = %v", err)
				return
			}

			// Run verification
			tt.verify(t, decoded)

			t.Logf("Successfully updated session: %s", tt.name)
		})
	}
}

func TestRoundTripEncodeDecodeSession(t *testing.T) {
	secretKey := "your-secret-key-here-change-in-production"

	// Create comprehensive session data
	sessionData := map[string]interface{}{
		"username":    "roundtripuser",
		"email":       "roundtrip@example.com",
		"permissions": []interface{}{"read", "write", "execute"},
		"metadata": map[string]interface{}{
			"created_at": "2026-01-18T16:00:00Z",
			"ip_address": "192.168.1.1",
		},
		"active": true,
		"count":  float64(42),
	}

	// Encode
	encoded, err := EncodeSessionData("777", secretKey, sessionData)
	if err != nil {
		t.Fatalf("EncodeSessionData() error = %v", err)
	}

	// Decode
	signer := &DjangoSigner{
		SecretKey: secretKey,
		Salt:      "django.contrib.sessions.SessionStore",
		Sep:       ":",
		Algorithm: "sha256",
	}

	decoded, err := signer.UnsignObject(encoded, nil)
	if err != nil {
		t.Fatalf("UnsignObject() error = %v", err)
	}

	// Verify all fields
	if decoded["_auth_user_id"] != "777" {
		t.Errorf("_auth_user_id mismatch: got %v, want 777", decoded["_auth_user_id"])
	}
	if decoded["username"] != "roundtripuser" {
		t.Errorf("username mismatch: got %v, want roundtripuser", decoded["username"])
	}
	if decoded["email"] != "roundtrip@example.com" {
		t.Errorf("email mismatch: got %v", decoded["email"])
	}
	if decoded["active"] != true {
		t.Errorf("active mismatch: got %v, want true", decoded["active"])
	}
	if decoded["count"] != float64(42) {
		t.Errorf("count mismatch: got %v, want 42", decoded["count"])
	}

	t.Logf("Round-trip test successful. Decoded data: %+v", decoded)
}
